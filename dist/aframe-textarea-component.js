/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (() => {

eval("/* global AFRAME */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n/**\n * Textarea component for A-Frame.\n */\nAFRAME.registerComponent('textarea', {\n  schema: {\n    cols: {type: 'int', default: 40},\n    rows: {type: 'int', default: 20},\n    color: {type: 'color', default: 'black'},\n    backgroundColor: {type: 'color', default: 'white'},\n    selectionColor: {type: 'color', default: 'grey'},\n    disabledBackgroundColor: {type: 'color', default: 'lightgrey'},\n    disabled: {type: 'boolean', default: false},\n    text: {type: 'string', default: ''}\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.showCursorTimeout = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {x: 0, y: 0};\n    this.textarea = null;\n\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n    this.el.setObject3D('background', this.background.object3D);\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this._initCursor();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateCursorGeometry.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('text-changed', this._setShowCursorTimeout.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateCursorStyle.bind(this));\n    this.el.addEventListener('selection-changed', this._updateCursorGeometry.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('selection-changed', this._setShowCursorTimeout.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateCursorGeometry.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateCursorGeometry.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.cursorMesh.visible = !this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  blur: function () {\n    this.textarea.blur();\n  },\n  getText: function () {\n    return this.textarea.value;\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _initCursor: function () {\n    this.cursor = document.createElement('a-entity');\n    this.cursorGeo = new THREE.PlaneGeometry(1, 1);\n    this.cursorMat = new THREE.MeshBasicMaterial({\n      color: 'black',\n      transparent: true,\n      opacity: 0.5\n    });\n    this.cursorMesh = new THREE.Mesh(this.cursorGeo, this.cursorMat);\n    this.cursor.setObject3D('mesh', this.cursorMesh);\n    this.el.appendChild(this.cursor);\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {x: 0, y: this.charHeight * this.data.rows / 2, z: 0});\n    this.background.setAttribute('scale', {x: 1.05, y: this.charHeight * this.data.rows * 1.05, z: 1});\n    this.background.setAttribute('position', {x: 0, y: 0, z: 0});\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (\n      this.selectionStart === this.textarea.selectionStart &&\n      this.selectionEnd === this.textarea.selectionEnd\n    ) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {old: lastStart, new: this.selectionStart, changed: this.selectionStart !== lastStart},\n      end: {old: lastEnd, new: this.selectionEnd, changed: this.selectionEnd !== lastEnd}\n    });\n  },\n  _setShowCursorTimeout: function () {\n    this.showCursorTimeout = 500;\n  },\n  tick: function (time, delta) {\n    this._updateCursorVisibility(delta);\n    this._checkAndUpdateSelection();\n    this._checkAndUpdateText();\n  },\n  _updateCursorVisibility: function (delta) {\n    if (document.activeElement === this.textarea) {\n      if (this.showCursorTimeout > 0) {\n        this.showCursorTimeout -= delta;\n        this.cursorMesh.visible = true;\n      } else {\n        if (this.blinkEnabled) {\n          if (Date.now() - this.lastBlink > 500) {\n            this.cursorMesh.visible = !this.cursorMesh.visible;\n            this.lastBlink = Date.now();\n          }\n        } else if (this.selectionStart !== this.selectionEnd) {\n          this.cursorMesh.visible = true;\n        }\n      }\n    } else {\n      this.cursorMesh.visible = false;\n    }\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    var i;\n    var startChanged = false;\n    var endChanged = false;\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? (prevLine.start + prevLine.length + 1) : this.lines[i].start;\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n        break;\n      }\n    }\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {changed: startChanged},\n        end: {changed: endChanged}\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    var changed = false;\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n    var changed = true;\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateCursorStyle: function () {\n    if (this.selectionStart === this.selectionEnd) {\n      this.blinkEnabled = true;\n      this.cursorMat.color.setStyle('black');\n      this.cursorMat.transparent = false;\n    } else {\n      this.blinkEnabled = false;\n      this.cursorMat.color.setStyle(this.data.selectionColor);\n      this.cursorMesh.visible = true;\n      this.cursorMat.transparent = true;\n    }\n  },\n  _updateCursorGeometry: function () {\n    if (!this.startIndexInfo) {\n      return;\n    }\n    const startLine = Math.max(this.origin.y, this.startIndexInfo.line.index);\n    const endLine = Math.min(this.origin.y + this.data.rows - 1, this.endIndexInfo.line.index);\n    const maxIndex = this.origin.x + this.data.cols;\n    const geos = [];\n    const mesh = new THREE.Object3D();\n    for (var i = startLine; i <= endLine; i++) {\n      var size;\n      var offset = 0;\n      if (endLine === startLine) {\n        offset = Math.max(this.origin.x, this.selectionStart - this.startIndexInfo.line.start);\n        const end = Math.min(maxIndex, this.selectionEnd - this.startIndexInfo.line.start);\n        size = Math.max(0.2, end - offset);\n      } else {\n        var end;\n        if (i === this.startIndexInfo.line.index) {\n          offset = Math.max(this.origin.x, this.selectionStart - this.startIndexInfo.line.start);\n          end = Math.min(maxIndex, this.startIndexInfo.line.length);\n        } else if (i === this.endIndexInfo.line.index) {\n          offset = this.origin.x;\n          end = Math.min(maxIndex, this.selectionEnd - this.endIndexInfo.line.start);\n        } else {\n          offset = this.origin.x;\n          end = Math.min(maxIndex, this.lines[i].length);\n        }\n        size = end - offset;\n      }\n      mesh.scale.set(\n        this.charWidth * size,\n        this.charHeight,\n        1\n      );\n      mesh.position.set(\n        offset * this.charWidth + this.charWidth * size / 2 - 0.5 - this.origin.x * this.charWidth,\n        -i * this.charHeight + (this.charHeight * this.data.rows) / 2 - this.charHeight / 2 + this.origin.y * this.charHeight,\n        0.002\n      );\n      mesh.updateMatrix();\n      const geo = new THREE.PlaneGeometry(1, 1);\n      geo.applyMatrix4(mesh.matrix);\n      geos.push(geo);\n    }\n    this.cursorMesh.geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geos);\n    this.cursorMesh.geometry.verticesNeedUpdate = true;\n    this.cursorMesh.geometry.needsUpdate = true;\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    var counter = 0;\n    for (var i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows)\n      .map(function (line) {\n        return line.substr(this.origin.x, this.data.cols) || ' ';\n      }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n    if (text === this.text) {\n      return;\n    }\n    this.text = text;\n    this._emit('text-changed');\n  }\n});\n\n\n//# sourceURL=webpack://aframe-textarea-component/./index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.js"]();
/******/ 	
/******/ })()
;